<html>
	<body>
		<script>
			const httpProtocol = "https://"
			const host = "openchat.dr-useless.workers.dev"

			const sigKeyParams = {
				name: "ECDSA",
				namedCurve: "P-384"
			}
			
			const sigAlgorithm = {
				name: "ECDSA",
				hash: "SHA-384"
			}

			const hashAlgorithm = "SHA-256"

			genKeyPair = () => {
				return crypto.subtle.generateKey(sigKeyParams, true, ["sign", "verify"])
				.then(keyPair => {
					const priv = crypto.subtle.exportKey("jwk", keyPair.privateKey)
					const pub = crypto.subtle.exportKey("jwk", keyPair.publicKey)
					return Promise.all([priv, pub]).then(keys => {return { priv: keys[0], pub: keys[1]}})
				})
				.catch(e => console.log('exportKey failed', e))
			}

			getKeyPair = () => {
				const priv = crypto.subtle.importKey("jwk", JSON.parse(localStorage.getItem("privKey")), sigKeyParams, true, ["sign"])
				const pub = crypto.subtle.importKey("jwk", JSON.parse(localStorage.getItem("pubKey")), sigKeyParams, true, ["verify"])
				return Promise.all([priv, pub]).then(keys => {return { priv: keys[0], pub: keys[1]}})
			}

			getHash = data => {
				return crypto.subtle.digest(hashAlgorithm, data)
			}

			init = () => {
				// ensure we have keys
				const storedPrivKey = localStorage.getItem("privKey")
				const storedPubKey = localStorage.getItem("pubKey")
				if (!storedPrivKey || !storedPubKey) {
					return genKeyPair().then(keyPair => {
						console.log('got new keyPair', keyPair)
						localStorage.setItem("privKey", JSON.stringify(keyPair.priv))
						localStorage.setItem("pubKey", JSON.stringify(keyPair.pub))
						return getKeyPair()
					})
				}
				return getKeyPair()
			}

			getChallenge = sigPubJwkHashBase58 => {
				const stored = localStorage.getItem("challenge")
				const request = () => {
					return fetch(`${httpProtocol}${host}/${sigPubJwkHashBase58}/challenge`)
					.then(r => r.json())
					.then(challenge => {
						console.log('fetched challenge', challenge)
						localStorage.setItem("challenge", JSON.stringify(challenge))
						return challenge
					})
				}
				if (!stored) {
					return request()
				}
				const challenge = JSON.parse(stored)
				if (Date.now() > challenge.exp) {
					return request()
				}
				return Promise.resolve(challenge)
			}

			getMessages = (sigPubJwkHashBase58, sigPubJwkBase58, signedChallengeBase58) => {
				return fetch(`${httpProtocol}${host}/${sigPubJwkHashBase58}`, {
					headers: {
						"oc-pk": sigPubJwkBase58,
						"oc-sig": signedChallengeBase58
					}
				}).then(r => r.json())
			}

			sendMessage = (sigPubJwkHashBase58, message) => {
				return fetch(`${httpProtocol}${host}/${sigPubJwkHashBase58}`, {
					method: "POST",
					body: JSON.stringify(message)
				})
			}
			
			init().then(keyPair => {
				crypto.subtle.exportKey("jwk", keyPair.pub).then(sigPubJwk => {
					const encoder = new TextEncoder()
					const sigPubJwkBytes = encoder.encode(JSON.stringify(sigPubJwk))
					getHash(sigPubJwkBytes)
						.then(sigPubJwkHash => base58().encode(new Uint8Array(sigPubJwkHash)))
						.then(sigPubJwkHashBase58 => {
							console.log("sigPubJwkHashBase58", sigPubJwkHashBase58)
							getChallenge(sigPubJwkHashBase58).then(challenge => {
								// sign it with privKey
								const challengeBytes = encoder.encode(challenge.txt)
								crypto.subtle.sign(sigAlgorithm, keyPair.priv, challengeBytes).then(signed => {
									const signedChallengeBase58 = base58().encode(new Uint8Array(signed))
									const sigPubJwkBytes = encoder.encode(JSON.stringify(sigPubJwk))
									const sigPubJwkBase58 = base58().encode(sigPubJwkBytes)									
									// test auth,
									// get messages with signed challenge
									getMessages(sigPubJwkHashBase58, sigPubJwkBase58, signedChallengeBase58)
									.then(m => console.log("messages", m.messages, m.error))
									.then(() => {
										// test websockets
										const websocket = new WebSocket(`wss://${host}/${sigPubJwkHashBase58}`)
										websocket.addEventListener("message", event => {
											const message = JSON.parse(event.data)
											console.log("client got", message)
											if (message.challenge) {
												const challenge = JSON.parse(message.challenge)
												websocket.send(JSON.stringify({signedChallengeBase58, sigPubJwkBase58}))
												// now we're authenticated & will recieve messages

												// send a test to ourselves
												sendMessage(sigPubJwkHashBase58, {message: "This is a test"})
											}
										})
									})
							})
						})
					})
				})
			});

			base58 = () => {
				// https://github.com/45678/Base58
				const result = {}
				const ALPHABET = "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"
				const ALPHABET_MAP = {}
				let i = 0
			
				while (i < ALPHABET.length) {
					ALPHABET_MAP[ALPHABET.charAt(i)] = i;
					i++
				}
			
				result.encode = buffer => {
					let carry, digits, j
					if (buffer.length === 0) {
						return ""
					}
					i = void 0
					j = void 0
					digits = [0]
					i = 0
					while (i < buffer.length) {
						j = 0
						while (j < digits.length) {
							digits[j] <<= 8
							j++
						}
						digits[0] += buffer[i]
						carry = 0
						j = 0
						while (j < digits.length) {
							digits[j] += carry
							carry = (digits[j] / 58) | 0
							digits[j] %= 58
							++j
						}
						while (carry) {
							digits.push(carry % 58)
							carry = (carry / 58) | 0
						}
						i++
					}
					i = 0
					while (buffer[i] === 0 && i < buffer.length - 1) {
						digits.push(0)
						i++
					}
					return digits.reverse().map(function(digit) {
						return ALPHABET[digit]
					}).join("")
				};
			
				result.decode = string => {
					let bytes, c, carry, j
					if (string.length === 0) {
						return new Uint8Array(0)
					}
					i = void 0
					j = void 0
					bytes = [0]
					i = 0
					while (i < string.length) {
						c = string[i]
						if (!(c in ALPHABET_MAP)) {
							throw "Base58.decode received unacceptable input. Character '" + c + "' is not in the Base58 alphabet."
						}
						j = 0
						while (j < bytes.length) {
							bytes[j] *= 58
							j++
						}
						bytes[0] += ALPHABET_MAP[c]
						carry = 0
						j = 0
						while (j < bytes.length) {
							bytes[j] += carry
							carry = bytes[j] >> 8
							bytes[j] &= 0xff
							++j
						}
						while (carry) {
							bytes.push(carry & 0xff)
							carry >>= 8
						}
						i++
					}
					i = 0
					while (string[i] === "1" && i < string.length - 1) {
						bytes.push(0)
						i++
					}
					return new Uint8Array(bytes.reverse())
				}
			
				return result
			}
		</script>		
	</body>
</html>